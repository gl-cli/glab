// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/cli/internal/git (interfaces: Git)
//
// Generated by this command:
//
//	mockgen -typed -destination=./git_runner.go -package=gittest gitlab.com/gitlab-org/cli/internal/git Git
//

// Package gittest is a generated GoMock package.
package gittest

import (
	reflect "reflect"

	git "gitlab.com/gitlab-org/cli/internal/git"
	gomock "go.uber.org/mock/gomock"
)

// MockGit is a mock of Git interface.
type MockGit struct {
	ctrl     *gomock.Controller
	recorder *MockGitMockRecorder
	isgomock struct{}
}

// MockGitMockRecorder is the mock recorder for MockGit.
type MockGitMockRecorder struct {
	mock *MockGit
}

// NewMockGit creates a new mock instance.
func NewMockGit(ctrl *gomock.Controller) *MockGit {
	mock := &MockGit{ctrl: ctrl}
	mock.recorder = &MockGitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGit) EXPECT() *MockGitMockRecorder {
	return m.recorder
}

// CheckoutBranch mocks base method.
func (m *MockGit) CheckoutBranch(branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckoutBranch", branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckoutBranch indicates an expected call of CheckoutBranch.
func (mr *MockGitMockRecorder) CheckoutBranch(branch any) *MockGitCheckoutBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckoutBranch", reflect.TypeOf((*MockGit)(nil).CheckoutBranch), branch)
	return &MockGitCheckoutBranchCall{Call: call}
}

// MockGitCheckoutBranchCall wrap *gomock.Call
type MockGitCheckoutBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitCheckoutBranchCall) Return(arg0 error) *MockGitCheckoutBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitCheckoutBranchCall) Do(f func(string) error) *MockGitCheckoutBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitCheckoutBranchCall) DoAndReturn(f func(string) error) *MockGitCheckoutBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CheckoutNewBranch mocks base method.
func (m *MockGit) CheckoutNewBranch(branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckoutNewBranch", branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckoutNewBranch indicates an expected call of CheckoutNewBranch.
func (mr *MockGitMockRecorder) CheckoutNewBranch(branch any) *MockGitCheckoutNewBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckoutNewBranch", reflect.TypeOf((*MockGit)(nil).CheckoutNewBranch), branch)
	return &MockGitCheckoutNewBranchCall{Call: call}
}

// MockGitCheckoutNewBranchCall wrap *gomock.Call
type MockGitCheckoutNewBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitCheckoutNewBranchCall) Return(arg0 error) *MockGitCheckoutNewBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitCheckoutNewBranchCall) Do(f func(string) error) *MockGitCheckoutNewBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitCheckoutNewBranchCall) DoAndReturn(f func(string) error) *MockGitCheckoutNewBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitBody mocks base method.
func (m *MockGit) CommitBody(sha string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitBody", sha)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitBody indicates an expected call of CommitBody.
func (mr *MockGitMockRecorder) CommitBody(sha any) *MockGitCommitBodyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitBody", reflect.TypeOf((*MockGit)(nil).CommitBody), sha)
	return &MockGitCommitBodyCall{Call: call}
}

// MockGitCommitBodyCall wrap *gomock.Call
type MockGitCommitBodyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitCommitBodyCall) Return(arg0 string, arg1 error) *MockGitCommitBodyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitCommitBodyCall) Do(f func(string) (string, error)) *MockGitCommitBodyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitCommitBodyCall) DoAndReturn(f func(string) (string, error)) *MockGitCommitBodyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commits mocks base method.
func (m *MockGit) Commits(baseRef, headRef string) ([]*git.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commits", baseRef, headRef)
	ret0, _ := ret[0].([]*git.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commits indicates an expected call of Commits.
func (mr *MockGitMockRecorder) Commits(baseRef, headRef any) *MockGitCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commits", reflect.TypeOf((*MockGit)(nil).Commits), baseRef, headRef)
	return &MockGitCommitsCall{Call: call}
}

// MockGitCommitsCall wrap *gomock.Call
type MockGitCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitCommitsCall) Return(arg0 []*git.Commit, arg1 error) *MockGitCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitCommitsCall) Do(f func(string, string) ([]*git.Commit, error)) *MockGitCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitCommitsCall) DoAndReturn(f func(string, string) ([]*git.Commit, error)) *MockGitCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentBranch mocks base method.
func (m *MockGit) CurrentBranch() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentBranch")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentBranch indicates an expected call of CurrentBranch.
func (mr *MockGitMockRecorder) CurrentBranch() *MockGitCurrentBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentBranch", reflect.TypeOf((*MockGit)(nil).CurrentBranch))
	return &MockGitCurrentBranchCall{Call: call}
}

// MockGitCurrentBranchCall wrap *gomock.Call
type MockGitCurrentBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitCurrentBranchCall) Return(arg0 string, arg1 error) *MockGitCurrentBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitCurrentBranchCall) Do(f func() (string, error)) *MockGitCurrentBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitCurrentBranchCall) DoAndReturn(f func() (string, error)) *MockGitCurrentBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DefaultBranch mocks base method.
func (m *MockGit) DefaultBranch(remote string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DefaultBranch", remote)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DefaultBranch indicates an expected call of DefaultBranch.
func (mr *MockGitMockRecorder) DefaultBranch(remote any) *MockGitDefaultBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DefaultBranch", reflect.TypeOf((*MockGit)(nil).DefaultBranch), remote)
	return &MockGitDefaultBranchCall{Call: call}
}

// MockGitDefaultBranchCall wrap *gomock.Call
type MockGitDefaultBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitDefaultBranchCall) Return(arg0 string, arg1 error) *MockGitDefaultBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitDefaultBranchCall) Do(f func(string) (string, error)) *MockGitDefaultBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitDefaultBranchCall) DoAndReturn(f func(string) (string, error)) *MockGitDefaultBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteLocalBranch mocks base method.
func (m *MockGit) DeleteLocalBranch(branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteLocalBranch", branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteLocalBranch indicates an expected call of DeleteLocalBranch.
func (mr *MockGitMockRecorder) DeleteLocalBranch(branch any) *MockGitDeleteLocalBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLocalBranch", reflect.TypeOf((*MockGit)(nil).DeleteLocalBranch), branch)
	return &MockGitDeleteLocalBranchCall{Call: call}
}

// MockGitDeleteLocalBranchCall wrap *gomock.Call
type MockGitDeleteLocalBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitDeleteLocalBranchCall) Return(arg0 error) *MockGitDeleteLocalBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitDeleteLocalBranchCall) Do(f func(string) error) *MockGitDeleteLocalBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitDeleteLocalBranchCall) DoAndReturn(f func(string) error) *MockGitDeleteLocalBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasLocalBranch mocks base method.
func (m *MockGit) HasLocalBranch(branch string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasLocalBranch", branch)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasLocalBranch indicates an expected call of HasLocalBranch.
func (mr *MockGitMockRecorder) HasLocalBranch(branch any) *MockGitHasLocalBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasLocalBranch", reflect.TypeOf((*MockGit)(nil).HasLocalBranch), branch)
	return &MockGitHasLocalBranchCall{Call: call}
}

// MockGitHasLocalBranchCall wrap *gomock.Call
type MockGitHasLocalBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitHasLocalBranchCall) Return(arg0 bool, arg1 error) *MockGitHasLocalBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitHasLocalBranchCall) Do(f func(string) (bool, error)) *MockGitHasLocalBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitHasLocalBranchCall) DoAndReturn(f func(string) (bool, error)) *MockGitHasLocalBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LatestCommit mocks base method.
func (m *MockGit) LatestCommit(ref string) (*git.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestCommit", ref)
	ret0, _ := ret[0].(*git.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LatestCommit indicates an expected call of LatestCommit.
func (mr *MockGitMockRecorder) LatestCommit(ref any) *MockGitLatestCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestCommit", reflect.TypeOf((*MockGit)(nil).LatestCommit), ref)
	return &MockGitLatestCommitCall{Call: call}
}

// MockGitLatestCommitCall wrap *gomock.Call
type MockGitLatestCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitLatestCommitCall) Return(arg0 *git.Commit, arg1 error) *MockGitLatestCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitLatestCommitCall) Do(f func(string) (*git.Commit, error)) *MockGitLatestCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitLatestCommitCall) DoAndReturn(f func(string) (*git.Commit, error)) *MockGitLatestCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Push mocks base method.
func (m *MockGit) Push(remote, ref string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", remote, ref)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockGitMockRecorder) Push(remote, ref any) *MockGitPushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockGit)(nil).Push), remote, ref)
	return &MockGitPushCall{Call: call}
}

// MockGitPushCall wrap *gomock.Call
type MockGitPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitPushCall) Return(arg0 error) *MockGitPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitPushCall) Do(f func(string, string) error) *MockGitPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitPushCall) DoAndReturn(f func(string, string) error) *MockGitPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoteBranchExists mocks base method.
func (m *MockGit) RemoteBranchExists(remote, branch string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteBranchExists", remote, branch)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoteBranchExists indicates an expected call of RemoteBranchExists.
func (mr *MockGitMockRecorder) RemoteBranchExists(remote, branch any) *MockGitRemoteBranchExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteBranchExists", reflect.TypeOf((*MockGit)(nil).RemoteBranchExists), remote, branch)
	return &MockGitRemoteBranchExistsCall{Call: call}
}

// MockGitRemoteBranchExistsCall wrap *gomock.Call
type MockGitRemoteBranchExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRemoteBranchExistsCall) Return(arg0 bool, arg1 error) *MockGitRemoteBranchExistsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRemoteBranchExistsCall) Do(f func(string, string) (bool, error)) *MockGitRemoteBranchExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRemoteBranchExistsCall) DoAndReturn(f func(string, string) (bool, error)) *MockGitRemoteBranchExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UncommittedChangeCount mocks base method.
func (m *MockGit) UncommittedChangeCount() (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UncommittedChangeCount")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UncommittedChangeCount indicates an expected call of UncommittedChangeCount.
func (mr *MockGitMockRecorder) UncommittedChangeCount() *MockGitUncommittedChangeCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UncommittedChangeCount", reflect.TypeOf((*MockGit)(nil).UncommittedChangeCount))
	return &MockGitUncommittedChangeCountCall{Call: call}
}

// MockGitUncommittedChangeCountCall wrap *gomock.Call
type MockGitUncommittedChangeCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitUncommittedChangeCountCall) Return(arg0 int, arg1 error) *MockGitUncommittedChangeCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitUncommittedChangeCountCall) Do(f func() (int, error)) *MockGitUncommittedChangeCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitUncommittedChangeCountCall) DoAndReturn(f func() (int, error)) *MockGitUncommittedChangeCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UserName mocks base method.
func (m *MockGit) UserName() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserName")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserName indicates an expected call of UserName.
func (mr *MockGitMockRecorder) UserName() *MockGitUserNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserName", reflect.TypeOf((*MockGit)(nil).UserName))
	return &MockGitUserNameCall{Call: call}
}

// MockGitUserNameCall wrap *gomock.Call
type MockGitUserNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitUserNameCall) Return(arg0 string, arg1 error) *MockGitUserNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitUserNameCall) Do(f func() (string, error)) *MockGitUserNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitUserNameCall) DoAndReturn(f func() (string, error)) *MockGitUserNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
